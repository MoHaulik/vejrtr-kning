<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebXR Breathing App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      z-index: 1;
    }
    #start-button {
      padding: 10px 20px;
      font-size: 16px;
    }
    #status {
      margin-top: 10px;
      font-size: 18px;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 5px;
      display: none;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <button id="start-button">Start AR</button>
    <div id="status"></div>
  </div>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.1/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.150.1/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer;
    let analyser, dataArray;
    let particles;
    let clock = new THREE.Clock();

    // --- Breathing App Variables ---
    // Phases: "breathing" (natural breathing), "hold" (breath hold), "recovery" (deep recovery breath)
    let phase = "breathing"; 
    let breathCount = 0;
    const maxBreaths = 30;
    let cycleCount = 0;
    const maxCycles = 3; // You can adjust to 3-5 cycles as desired.
    let isInhaling = false;
    // Two thresholds to more reliably count a breath:
    const inhaleThreshold = 0.3;   // When the mic input is high enough (inhalation)
    const exhaleThreshold = 0.15;  // When the mic input falls low (exhalation)
    let holdStartTime = 0;
    let recoveryStartTime = 0;

    init();

    function init() {
      // Create scene and camera.
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 50);

      // Renderer with AR support.
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 0); // Transparent background.
      document.body.appendChild(renderer.domElement);

      // Attach start button event.
      document.getElementById('start-button').addEventListener('click', () => {
        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            if (supported) {
              const sessionInit = { optionalFeatures: ['dom-overlay'], domOverlay: { root: document.body } };
              navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
            } else {
              alert('WebXR AR session is not supported on this device.');
            }
          });
        } else {
          alert('WebXR is not supported in this browser.');
        }
      });
    }

    function onSessionStarted(session) {
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);
      document.getElementById('start-button').style.display = 'none';
      document.getElementById('status').style.display = 'block';

      // Begin the render loop.
      renderer.setAnimationLoop(render);

      // Set up audio analysis from the mic.
      navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then((stream) => {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        const bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        source.connect(analyser);
      });

      createParticles();
    }

    function createParticles() {
      const particleCount = 2000;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const sizes = [];

      for (let i = 0; i < particleCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.sqrt(Math.random()) * 5;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        const z = (Math.random() - 0.5) * 2;
        positions.push(x, y, z);

        const color = new THREE.Color();
        color.setHSL(Math.random(), 0.7, 0.7);
        colors.push(color.r, color.g, color.b);

        sizes.push(0.2 + Math.random() * 0.3);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

      const material = new THREE.ShaderMaterial({
        uniforms: {
          pointTexture: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png') },
          time: { value: 0 },
        },
        vertexShader: `
          attribute float size;
          attribute vec3 customColor;
          varying vec3 vColor;
          varying float vAlpha;
          uniform float time;
          void main() {
            vColor = customColor;
            vec3 pos = position;
            float dist = length(pos);
            // Slow down the forward/backward motion by reducing the multiplier.
            pos.z += sin(dist * 4.0 - time * 1.0) * 0.5;
            vAlpha = 1.0 - dist / 5.0;
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          uniform sampler2D pointTexture;
          varying vec3 vColor;
          varying float vAlpha;
          void main() {
            gl_FragColor = vec4(vColor, vAlpha);
            gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);
    }

    function render() {
      const delta = clock.getDelta();
      const time = clock.elapsedTime;
      let intensity = 0;
      
      // Get mic input intensity.
      if (analyser) {
        analyser.getByteFrequencyData(dataArray);
        const avgFrequency = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
        intensity = avgFrequency / 255;
      }

      // --- Phase Management ---
      if (phase === "breathing") {
        // Detect the start and end of an inhale/exhale cycle.
        if (intensity > inhaleThreshold && !isInhaling) {
          isInhaling = true;
        }
        if (intensity < exhaleThreshold && isInhaling) {
          breathCount++;
          isInhaling = false;
          if (breathCount >= maxBreaths) {
            phase = "hold";
            holdStartTime = time;
          }
        }
      } else if (phase === "hold") {
        // Transition to recovery if the user starts breathing again or 60 seconds elapse.
        if (intensity > inhaleThreshold || (time - holdStartTime) > 60) {
          phase = "recovery";
          recoveryStartTime = time;
        }
      } else if (phase === "recovery") {
        // After 15 seconds of recovery, complete the cycle.
        if ((time - recoveryStartTime) > 15) {
          cycleCount++;
          if (cycleCount < maxCycles) {
            breathCount = 0;
            phase = "breathing";
          } else {
            renderer.setAnimationLoop(null);
            document.getElementById('status').innerHTML = "Session Finished. Thank you!";
          }
        }
      }

      // --- Adjust Animation Parameters Based on Phase ---
      let speedFactor = 1.0;
      let sizeMultiplier = 1.0;
      if (phase === "hold") {
        speedFactor = 0.2;  // Slower particle movement during hold.
        sizeMultiplier = 0.5;  // Particles shrink during hold.
      } else if (phase === "recovery") {
        let t = Math.min((time - recoveryStartTime) / 15, 1.0);
        sizeMultiplier = 0.5 + 0.5 * t;
      }

      // Update particle animation with slower forward/backward movement.
      particles.material.uniforms.time.value = time;
      const positions = particles.geometry.attributes.position.array;
      const sizes = particles.geometry.attributes.size.array;
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const y = positions[i + 1];
        const dist = Math.sqrt(x * x + y * y);
        // Reduced time multiplier to slow the oscillation.
        positions[i + 2] = Math.sin(dist * 4 - time * speedFactor) * (0.5 + intensity);
        sizes[i / 3] = ((0.5 + intensity * 3) * (1.0 - dist / 5.0)) * sizeMultiplier;
      }
      particles.geometry.attributes.position.needsUpdate = true;
      particles.geometry.attributes.size.needsUpdate = true;

      particles.rotation.z += 0.05 * delta * speedFactor;

      // Update the status overlay.
      let statusText = "";
      if (phase === "breathing") {
        statusText = `Cycle: ${cycleCount + 1}/${maxCycles}<br>Phase: Natural Breathing<br>Breaths: ${breathCount}/${maxBreaths}`;
      } else if (phase === "hold") {
        statusText = `Cycle: ${cycleCount + 1}/${maxCycles}<br>Phase: Breath Hold<br>Hold Time: ${(time - holdStartTime).toFixed(1)}s`;
      } else if (phase === "recovery") {
        statusText = `Cycle: ${cycleCount + 1}/${maxCycles}<br>Phase: Recovery Breath<br>Recovery Time: ${(time - recoveryStartTime).toFixed(1)}s`;
      }
      document.getElementById('status').innerHTML = statusText;

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
